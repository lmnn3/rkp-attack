#!/usr/bin/env python3
# -*- mode: python; tab-width: 4; indent-tabs-mode: nil -*-
#
# Copyright Â© 2014 Michael Catanzaro
#
# This file is part of RKP Attack.
#
# RKP Attack is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# RKP Attack is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with RKP Attack.  If not, see <http://www.gnu.org/licenses/>.

import networkx as nx
import matplotlib.pyplot as plt

import sensor

NUM_SENSORS = 42
SENSOR_RANGE = 0.2
KEYS_PER_SENSOR = 10
TOTAL_KEYS = 1000

def deploy_sensors(num_good, num_evil, sensor_range, keys_per_sensor):
    '''
    Scatters sensors in a uniform random distributon over a unit
    square. Returns an immutable physical graph indicating which
    sensors are in range of each other, and a logical graph indicating
    which physically-adjacent sensors initially share keys. Sensor
    objects are attributes of the nodes on the logical graph.
    '''
    physical_graph = nx.random_geometric_graph(num_good, sensor_range)
    nx.freeze(physical_graph)
    evil_physical_graph = nx.random_geometric_graph(num_evil, sensor_range)
    physical_graph = nx.disjoint_union(physical_graph, evil_physical_graph)

    physical_graph.ngood = num_good
    physical_graph.nevil = num_evil

    logical_graph = nx.Graph()
    logical_graph.add_nodes_from(physical_graph.nodes())

    for i in range(num_good + num_evil):
        logical_graph.node[i]['pos'] = physical_graph.node[i]['pos']
        logical_graph.node[i]['sensor'] = sensor.Sensor(
            keys_per_sensor, TOTAL_KEYS)

    sensors = nx.get_node_attributes(logical_graph, 'sensor')
    for s, t in physical_graph.edges():
        sensor.add_logical_edge_one_hop(physical_graph, logical_graph, s, t)
    return physical_graph, logical_graph


def display_graph(G_p, G_l):
    '''
    Displays a graph using matplotlib. Each node must have a pos
    attribute to ensure it can be positioned properly in a unit square.
    '''

    fig = plt.figure(figsize=(8,4))
    ax1 = fig.add_subplot( 121 )
    ax2 = fig.add_subplot( 122 )

    colors = ['g'] * G_p.ngood + ['r'] * G_p.nevil

    nx.draw_networkx(G_p, pos=nx.get_node_attributes( G_p, 'pos' ), ax=ax1, node_color=colors)
    nx.draw_networkx(G_l, pos=nx.get_node_attributes( G_l, 'pos' ), ax=ax2, node_color=colors)
    plt.show()


physical_graph, logical_graph = deploy_sensors(
    NUM_SENSORS, NUM_SENSORS, SENSOR_RANGE, KEYS_PER_SENSOR)
display_graph(physical_graph, logical_graph)
#display_graph(logical_graph)
